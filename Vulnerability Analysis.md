Identifier | Soort kwetsbaarheid
------------- | -------------
A1:2017  | Injection
A2:2017  | Broken Authentication
A3:2017  | Sensitive Data Exposure
A4:2017  | XML External Entities (XXE)
A5:2017   | Broken Access Control
A6:2017   | Security Misconfiguration
A7:2017  | Cross Site Scripting (XSS)
A8:2017   | Insecure Deserialization
A9:2017  | Using Components with Known Vulnerabilities
A10:2017   | Insufficient Logging & Monitoring

# Vulnerability Analysis
## A10:2017 Insufficient logging & Monitoring
### Description
De vulnerability houdt in dat er niet genoeg of (in mijn geval helemaal geen) logging of monitoring is toegevoegd.
De eindgebruiker en of beheerder kan moeilijk tot niet inzien welke acties er plaatsvinden en kan moeilijk onderscheid maken tussen goed aardige en kwaadaardige gebruikers. De applicatie geeft foutmeldingen terug op bepaalde acties maar geeft niet bepaalde informatie terug die je vaak in een logger zou stoppen, denk hierbij aan generieke actie info, debugging, warnings en of andere problemen die onstaan wanneer een actie wordt aangeroepen. Doordat we niet bijhouden wat er allemaal met het systeem gebeurd, is het moeilijk om te achterhalen wanneer wat plaats heeft gevonden.

#### Assessment of risk. 
##### Discussion of authentication and authorization.
Authorisatie en Authenticatie hebben geen toegevoegde waarde binnen deze vulnerability.
De omvang van de risico kan je bepalen op basis van het doel van de applicatie.
Als je deze daadwerkelijk in productie zou willen nemen is logging en monitoring aan te raden, vooral als je een login service aanbiedt en makkelijk wil inzien als er iets aan de hand is. Het kunnen inzien van de uitgevoerde acties en het vastleggen wanneer problemen optreden en wat deze inhouden geeft meer inzicht.

op het gebied van monitoring denk ik dat het voor deze app niet echt nodig heeft. Je hebt geen accounts en slaat geen persoonlijke gegevens op dus deze hoef je in principe niet goed in de gaten te houden. Het kunnen inzien van je services en of deze de gewenste resultaten geven kan je inprincipe goed testen waardoor monitoring op een applicatie van deze schaal minder is.
Beide zijn altijd fijn om te hebben aangezien de meerwaarde daadwerklijke aanwezig is.

### Counter-measures
Logging kan je opzich best wel eenvoudig toegevoegd worden door na elke command/actie het resultaat te loggen.
Er zijn verschillende API's of manieren waarop je dit kunt toepassen. Hiernaast heeft java.util ook een logger die je kan gebruiken. 
Que monitoring heb ik google moeten raadplegen en ben ik op Stackify uitgekomen. Het is een library waarmee je de services kan tracen (@Trace) en een overzicht pagina kan maken waar je alle service traces kan zien en bijhouden.

De applicatie voor de minor waar ik mee bezig ben is een Magic The Gathering deck builder die serverless werkt met lambda's en NoSQL.
aangezien we gebruik maken van AWS kunnen we de verschillende gebruikte services eenvoudig in een dashboard stoppen om inzicht te krijgen in het systeem. In de afbeelding hieronder zie je een voorbeeld van onze monitoring pagina waar je verschillende informatie ziet over de  services, hoe vaak ze zijn aangeroepen, wat de latency is en de error logs van alle services (valt buiten de image maar staat eronder).
![AWS Dashboard](dashboard.png?raw=true "AWS")
![AWS Logs](logsVoorbeeld.png?raw=true "AWS")

## A1:2017 Injection
### Description
SQL injection staat in 2021 nog steeds in de top 3 van meest voorkomende attacks die wordt uitgevoerd.
De hacker probeert doormiddel van environment variables, parameters, external and internal web services data te injecteren in het systeem of probeert door middel van SQL calls data uit het systeem te vissen. Voor dit project is de kans klein dat je op de meest gebruikelijke manieren een SQL injection uitgevoerd kan worden aangezien we geen SQL queries gebruiken. We gebruiken namelijk Hibernate die alle acties op de db uitvoerd door middel van parameterized statements. Hiernaast hebben we ook geen andere SQL queries gedefinieerd in de gameRepository waardoor alle acties 100% paramterized zijn.
#### Assessment of risk. 
##### Discussion of authentication and authorization.
Ook voor deze risico heeft authenticatie en authorizatie geen invloed op de werking van de aanval.
Ik heb het al even genoemd maar sql injections zoals ik ze ken worden vooral uitgevoerd door SQL queries op het syteem uit te voeren
of door deze te manipuleren: ``String query = "SELECT * FROM accounts WHERE custID='" + request.getParameter("id") + "'";`` 
is een voorbeeld van een simepele SQL query die eenvoudig te manipuleren is door een hacker. De hacker kan door middel van special characters (als de query niet ge-escaped is) of door simpel weg gokken op de gegeven query inputs data uit het systeem halen of erin verwerkken. 

Om dit tegen te gaan zijn 2 dingen die je kunt doen waarvan ik er sowieso 1 heb gedaan. Hibernate maakt gebruik van statements ipv queries om data uit de database op te halen. ``String sql="insert into emp values(?,?,?)"; `` is een simpel voorbeeld waar de ``?`` parameter aangegeven wordt die we kunnen invoeren door de setter methode van prepared statement aan te roepen. Hiberante doet dit allemaal onderwater waardoor we dit niet zelf hoeven te schrijven. Hiernaast is het mogelijk om escaping te gebruiken zoals je kunt zien in de simpele string query. ik weet niet zeker of Hibernate de de input zelf escaped maar ga hier eigenlijk wel vanuit. Ik kan hier bijna niks over vinden. Ook lees ik hier en daar dat character escaping SQL injecties niet tegen gaat maar als ik de OWASP website mag geloven is dit wel zo.

### Counter-measures
Ik denk dat ik dit redelijk in de assessment van het risico heb beschreven maar in het kort:
1. gebruik prepared statements ipv simpele SQL Queries.
2. Blokkeer special characters met namen: `'\/'

## A6:2017 Security Misconfiguration
### Description
De applicatie kent bijna geen security waardoor het heel simpel is om een spel van een andere gebruiker op te vragen of om deze te kapen. Het systeem kent over het algemeen alleen POST http requests en 1 GET request voor het ophalen van een game op basis van het id.
Een hacker zou in principe door een POST request op /game zijn eigen games kunnen beginnen zonder het systeem hiervoor te gebruiken.
hiernaast kan game informatie worden opgevgraagd door een GET request uit te voeren op /game/{gameId}. Alle endpoints staan open voor iedereen waardoor iedereen er bij kan.

#### Assessment of risk. 
##### Discussion of authentication and authorization.
Authenticatie en Authorisatie is zeker iets wat we zouden kunnen gebruiken om de game gegevens van verschillende gebruikers
te beveiligen en bij te houden. Een manier om dit te regelen zou door middel van login en JWT zijn. De JWT bestaat uit een header, payload en signature die je in de request meestuurd. In de payload kan je 'sub', 'name' en 'iat' zetten. Als de gebruiker inlogt zal het systeem een JWT token terug sturen die uniek is voor de gebruiker. De JWT kunnen we vervolgens gebruiken om de gebruiker te verifieren aan de hand van deze JWT. Als een gebruiker een request stuurt naar de server om bijvoorbeeld een nieuwe game te starten, moet de gebruiker de jwt meesturen in de Authorization header van de request. Het systeem controleert de signature en leest de payload data uit en verifieert bijvoorbeeld door een userId of de gebruiker is wie hij zegt dat hij is.

In een opdracht voor de Cload native software development minor gebruiken we deze toepassing i.c.m. AWS cognito die alle gebruiker data beheert.

##### voorbeeld JWT met Python

```
try:
        decoded_token = jwt.decode(
            app_encoder.strip_authorization(event["headers"]["Authorization"]),
            options={"verify_signature": False},
        )
    except ValueError:
        return {
            "statusCode": 400,
            "body": json.dumps({"message": "Header `Authorization` is not valid."}),
        }
    user_id = decoded_token["sub"]

    ## create new deck item ##
    item = {
        'pk': str(uuid.uuid4()),
        'sk': "deck_details",
        'name': data['name'],
        'totalValue': Decimal(0),
        'userId': user_id
    }
    table.put_item(Item=item)
    logger.info(f"A new deck has been created: {item}")
    
def strip_authorization(header, prefix="Bearer"):
    bearer, _, token = header.partition(" ")
    if bearer != prefix:
        raise ValueError("Invalid token")

    return token

```
Dit is een stukje voorbeeld code van de create_deck functie die we gebruiken in het systeem. Het systeem maakt gebruik van een NoSQL
database maar dat maakt voor het voorbeeld niet zoveel uit. Een gebruiker zal in deze service een POST request sturen met een body waar de gebruiker een naam voor zijn deck bepaalt. hiernaast wordt er in de Authorization deel van de header een JWT Bearer token gestuurd die door Cognito wordt gedecode.  Als de userId niet overeenkomt met de userId die bekend is bij AWS cognito zal het systeem een message sturen dat de Authorization niet valid is. 

Voor de lingo applicatie zouden we een zelfde soort implementatie kunnen maken waar het systeem een Authorization header vereist voor elke request. Deze wordt door het systeem uitgelezen en gecontroleerd of de gebruiker die is ingelogd overeenkomt met de gebruiker die request heeft verstuurd. Om dit te implementeren zouden we een login service moeten maken zodat een gebruiker kan registreren en inloggen.Ook hebben we een JWT decode service nodig die controleert of de ingelogde gebruiker de authorisatie heeft om de request uit te voeren. Dit zouden we dan kunnen doen door bepaalde user data in de JWT token te stoppen die geverifieerd wordt als de requst wordt verstuurd.

### Counter-measures
Qua implementatie voor de Java Lingo applicatie kunnen we verschillende API's gebruiken om JWT tokens te genereren en om de gebruiker te authoriseren. Aangezien we Spring boot gebruiken zouden we bijvoorbeeld Spring Security kunnen gebruiken. 
in essentie werkt dit als volgt. 
![JWT](jwt.png?raw=true "JWT")

1. De geberuiker stuurt een POST request met zijn login gegevens naar de server.
2. De server genereert een jwt token voor deze gebruiker.
3. De server stuurt de jwt token terug naar de gebruiker.
4. De gebruiker wil een game opvragen of starten een stuurt een POST request naar de server.
5. de server controleert de signature van de jwt token en haalt bijvoorbeeld de userId uit de payload van de token en controleert of deze overeenkomt met het systeem.
6. De server stuurt de response terug naar de gebruiker.



