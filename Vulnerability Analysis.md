Identifier | Soort kwetsbaarheid
------------- | -------------
A1:2017  | Injection
A2:2017  | Broken Authentication
A3:2017  | Sensitive Data Exposure
A4:2017  | XML External Entities (XXE)
A5:2017   | Broken Access Control
A6:2017   | Security Misconfiguration
A7:2017  | Cross Site Scripting (XSS)
A8:2017   | Insecure Deserialization
A9:2017  | Using Components with Known Vulnerabilities
A10:2017   | Insufficient Logging & Monitoring


1. Wat houdt de vulnerability in?
2. Hoe groot is het risico voor deze kwetsbaarheid binnen het project?
a. Wat als we authenticatie en autorisatie toevoegen?
3. Hoe wordt dit risico tegengegaan binnen het project?
a. Als je denkt dat (een onderdeel van) een library of framework dit voor je oplost, 
probeer dan uit te zoeken welk onderdeel dit is en hoe deze dat tegengaat.  
Je kan in Markdown tussenkopjes maken met een #-teken, bijvoorbeeld:

# Vulnerability Analysis
## A10:2017 Insufficient logging & Monitoring
### Description
De vulnerability houdt in dat er niet genoeg of (in mijn geval helemaal geen) logging of monitoring is toegevoegd.
De eindgebruiker en of beheerder kan moeilijk tot niet inzien welke acties er plaatsvinden en kan moeilijk onderscheid maken tussen goed aardige en kwaadaardige gebruikers. De applicatie geeft foutmeldingen terug op bepaalde acties maar geeft niet bepaalde informatie terug die je vaak in een logger zou stoppen, denk hierbij aan generieke actie info, debugging, warnings en of andere problemen die onstaan wanneer een actie wordt aangeroepen. Doordat we niet bijhouden wat er allemaal met het systeem gebeurd, is het moeilijk om te achterhalen wanneer wat plaats heeft gevonden.

#### Assessment of risk. 
##### Discussion of authentication and authorization.
Authorisatie en Authenticatie hebben geen toegevoegde waarde binnen deze vulnerability.
De omvang van de risico kan je bepalen op basis van het doel van de applicatie.
Als je deze daadwerkelijk in productie zou willen nemen had ik op zn minst logging toegevoegd. 
het kunnen inzien van de uitgevoerde acties en het vastleggen wanneer problemen optreden en wat deze inhouden geeft meer inzicht.

op het gebied van monitoring denk ik dat het voor deze app niet echt nodig heeft. Je hebt geen accounts en slaat geen persoonlijke gegevens op dus deze hoef je in principe niet goed in de gaten te houden. Het kunnen inzien van je services en of deze de gewenste resultaten geven kan je inprincipe goed testen waardoor monitoring op een applicatie van deze schaal minder is.

Beide zijn altijd fijn om te hebben aangezien de meerwaarde daadwerklijke aanwezig is.
### Counter-measures
Logging kan je opzich best wel eenvoudig toegevoegd worden door na elke command/actie het resultaat te loggen.
Er zijn verschillende API's of manieren waarop je dit kunt toepassen. Hiernaast heeft java.util ook een logger die je kan gebruiken. 
Que monitoring heb ik google moeten raadplegen en ben ik op Stackify uitgekomen. Het is een library waarmee je de services kan tracen (@Trace) en een overzicht pagina kan maken waar je alle service traces kan zien en bijhouden.

## A1:2017 Injection
### Description
SQL injection staat in 2021 nog steeds in de top 3 van meest voorkomende attacks die wordt uitgevoerd.
De hacker probeert doormiddel van environment variables, parameters, external and internal web services data te injecteren in het systeem of probeert door middel van SQL calls data uit het systeem te vissen. Voor dit project is de kans klein dat je op be meest gebruikelijke manieren een SQL injection uitgevoerd kan worden aangezien we geen SQL queries gebruiken. We gebruiken namelijk Hibernate die alle acties die op de database uitvoerd en gebruik maakt van parameterized statements ipv String sql queries. Hiernaast hebben we ook geen andere SQL queries gedefinieerd in de gameRepository waardoor alle acties 100% paramterized zijn.
#### Assessment of risk. 
##### Discussion of authentication and authorization.
Ook voor deze risico heeft authenticatie en authorizatie geen invloed op de werking van de aanval.
Ik heb het al even genoemd maar sql injections zoals ik ze ken worden vooral uitgevoerd door SQL queries op het syteem uit te voeren
of door deze te manipuleren: ``String query = "SELECT * FROM accounts WHERE custID='" + request.getParameter("id") + "'";`` 
is een voorbeeld van een simepele SQL query die eenvoudig te manipuleren is door een hacker. De hacker kan door middel van special characters (als de query niet ge-escaped is) of door simpel weg gokken op de gegeven query inputs data uit het systeem halen of erin verwerkken. 

Om dit tegen te gaan zijn 2 dingen die je kunt doen waarvan ik er sowieso 1 heb gedaan. Hibernate maakt gebruik van statements ipv queries om data uit de database op te halen. ``String sql="insert into emp values(?,?,?)"; `` is een simpel voorbeeld waar de ``?`` parameter aangegeven wordt die we kunnen invoeren door de setter methode van prepared statement aan te roepen. Hiberante doet dit allemaal onderwater waardoor we dit niet zelf hoeven te schrijven. Hiernaast is het mogelijk om escaping te gebruiken zoals je kunt zien in de simpele string query. ik weet niet zeker of Hibernate de de input zelf escaped maar ga hier eigenlijk wel vanuit. Ik kan hier bijna niks over vinden. Ook lees ik hier en daar dat character escaping SQL injecties niet tegen gaat maar als ik de OWASP website mag geloven is dit wel zo.

### Counter-measures
Ik denk dat ik dit redelijk in de assessment van het risico heb beschreven maar in het kort:
1. gebruik prepared statements ipv simpele SQL Queries.
2. Blokkeer special characters met namen: `'\/'

## A6:2017 Security Misconfiguration
### Description
De applicatie kent bijna geen security waardoor het heel simpel is om een spel van een andere gebruiker op te vragen of om deze te kapen. Het systeem kent over het algemeen alleen POST http requests en 1 GET request voor het ophalen van een game op basis van het id.
Een hacker zou in principe door een POST request op /game zijn eigen games kunnen beginnen zonder het systeem hiervoor te gebruiken.
hiernaast kan game informatie worden opgevgraagd door een GET request uit te voeren op /game/{gameId}. Alle endpoints staan open voor iedereen waardoor iedereen er bij kan.

#### Assessment of risk. 
##### Discussion of authentication and authorization.
Authenticatie en Authorisatie is zeker iets wat we zouden kunnen gebruiken om de game gegevens van verschillende gebruikers
te beveiligen en bij te houden. Een manier om dit te regelen zouden we JWT kunnen gebruiken die meegestuurd word in de header van de request. De JWT bestaat uit een header, payload en signature die je in de request meestuurd. In de payload kan je 'sub', 'name' en 'iat' zetten. In het sub deel van de payload kunnen we een userId meegeven die verbonden is aan de gebruiker van een spel en opgeslagen is in de database. als een spel gestart wordt zal het systeem de JWT token moeten decode en de 'sub' waarde uit de payload lezen. Als deze overeenkomt met het id van de gebruiker die het request heeft verstuurd dan gaat de service verder. 

In een opdracht voor de Cload native software development minor gebruiken we deze toepassing i.c.m. AWS cognito die alle gebruiker data beheert.

##### voorbeeld JWT met Python

```
try:
        decoded_token = jwt.decode(
            app_encoder.strip_authorization(event["headers"]["Authorization"]),
            options={"verify_signature": False},
        )
    except ValueError:
        return {
            "statusCode": 400,
            "body": json.dumps({"message": "Header `Authorization` is not valid."}),
        }
    user_id = decoded_token["sub"]

    ## create new deck item ##
    item = {
        'pk': str(uuid.uuid4()),
        'sk': "deck_details",
        'name': data['name'],
        'totalValue': Decimal(0),
        'userId': user_id
    }
    table.put_item(Item=item)
    logger.info(f"A new deck has been created: {item}")
    
def strip_authorization(header, prefix="Bearer"):
    bearer, _, token = header.partition(" ")
    if bearer != prefix:
        raise ValueError("Invalid token")

    return token

```
Dit is een stukje voorbeeld code van de create_deck functie die we gebruiken in het systeem. Het systeem maakt gebruik van een NoSQL
database maar dat maakt voor het voorbeeld niet zoveel uit. Een gebruiker zal in deze service een POST request sturen met een body waar de gebruiker een naam voor zijn deck bepaalt. hiernaast wordt er in de Authorization deel van de header een JWT Bearer token gestuurd die door Cognito wordt gedecode.  Als de userId niet overeenkomt met de userId die bekend is bij AWS cognito zal het systeem een message sturen dat de Authorization niet valid is. 

Voor de lingo applicatie zouden we een zelfde soort implementatie kunnen maken waar het systeem een Authorization header vereist voor elke request. Deze wordt door het systeem uitgelezen en gecontroleerd of de gebruiker die is ingelogd overeenkomt met de gebruiker die request heeft verstuurd. Om dit te implementeren zouden we een login service moeten maken zodat een gebruiker kan registreren en inloggen.Ook hebben we een JWT decode service nodig die controleert of de ingelogde gebruiker de authorisatie heeft om de request uit te voeren. Dit zouden we dan kunnen doen door bepaalde user data in de JWT token te stoppen die geverifieerd wordt als de requst wordt verstuurd.

### Counter-measures
Qua implementatie voor de Java Lingo applicatie kunnen we verschillende API's gebruiken om JWT tokens te genereren en om de gebruiker te authoriseren. Aangezien we Spring boot gebruiken zouden we bijvoorbeeld Spring Security kunnen gebruiken. 
in essentie werkt dit als volgt. 
![JWT](jwt.png?raw=true "JWT")

1. De geberuiker stuurt een POST request met zijn login gegevens naar de server.
2. De server genereert een jwt token voor deze gebruiker.
3. De server stuurt de jwt token terug naar de gebruiker.
4. De gebruiker wil een game opvragen of starten een stuurt een POST request naar de server.
5. de servier controleert de signature van de jwt token en haalt bijvoorbeeld de userId uit de payload van de token en controleert of deze overeenkomt met het systeem.
6. De server stuurt de response terug naar de gebruiker.



